' Gambas class file

Create Private
Static Private mBestIter As New Long[4]

Static Public Function Rfc2898DeriveBytes(password As String, salt As Byte[], iterationCount As Long, keySize As Integer, hash As Byte) As Byte[]

  Dim hClass, sSalt, sOut As String

  Select Case hash
    Case HashAlgorithm.SHA256
      hClass = "sha256"
    Case HashAlgorithm.SHA384
      hClass = "sha384"
    Case HashAlgorithm.SHA512
      hClass = "sha512"
    Case Else
      hClass = "sha1"
  End Select
  sSalt = ByteString.ByteArrayToString(salt)
  sOut = OpenSSL.Pbkdf2(password, sSalt, iterationCount, keySize, hClass)
  If Not sOut Then Return Null
  Return ByteString.String8ToByteArray(sOut)

End

Static Public Function BestIterationFor(hash As Byte) As Long

  If mBestIter[hash - 1] = 0 Then mBestIter[hash - 1] = GetBestIterationFor(hash)
  Return mBestIter[hash - 1]

End

Static Private Function GetBestIterationFor(hash As Byte) As Long

  Dim derSize As Integer
  Dim iterations, expectedIterations As Long
  Dim sTime, eTime As Float
  Dim pass As String
  Dim salt, derB As Byte[]

  pass = "CorrectHorseBatteryStaple"
  salt = New Byte[16]
  cOpenSSL.GetRandomBytes(ByRef salt)
  iterations = 10000
  expectedIterations = 0
  derSize = 32 * 2 + 2
  Do
    sTime = Timer
    derB = Me.Rfc2898DeriveBytes(pass, salt, iterations, derSize, hash)
    eTime = Timer - sTime
    derB.Clear
    If eTime > 1.0 Then Return iterations
    If expectedIterations = 0 Then
      expectedIterations = iterations / eTime
      expectedIterations = Ceil(expectedIterations / 10000) * 10000
      iterations = expectedIterations
    Else
      iterations = iterations + 10000
    Endif
  Loop
  Return 0

End
